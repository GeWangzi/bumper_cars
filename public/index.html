<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Three.js Bumper Cars</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    #respawnOverlay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.75);
      color: #ffdd66;
      font-size: 22px;
      border-radius: 10px;
      display: none;
      z-index: 10;
      letter-spacing: 0.03em;
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.7);
    }
  </style>
</head>

<body>
  <div id="respawnOverlay">Respawning in 3â€¦ (Streak: 0)</div>

  <script type="module">
    import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const socket = io();

    const respawnOverlay = document.getElementById("respawnOverlay");

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 15, 25);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const ARENA_RADIUS = 18;
    const floorGeo = new THREE.CircleGeometry(ARENA_RADIUS, 64);

    function createPolkaDotTexture() {
      const size = 256;
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#202020";
      ctx.fillRect(0, 0, size, size);

      ctx.fillStyle = "#3a3a3a";
      const spacing = 32;
      const radius = 4;

      for (let y = spacing / 2; y < size; y += spacing) {
        for (let x = spacing / 2; x < size; x += spacing) {
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(8, 8);
      tex.anisotropy = 8;
      return tex;
    }

    const floorTex = createPolkaDotTexture();

    const floorMat = new THREE.MeshStandardMaterial({
      map: floorTex,
      metalness: 0.2,
      roughness: 0.7,
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const borderGeo = new THREE.RingGeometry(
      ARENA_RADIUS - 0.2,
      ARENA_RADIUS + 0.2,
      64
    );
    const borderMat = new THREE.MeshBasicMaterial({
      color: 0xffcc33,
      side: THREE.DoubleSide,
    });
    const border = new THREE.Mesh(borderGeo, borderMat);
    border.rotation.x = -Math.PI / 2;
    border.position.y = 0.02;
    scene.add(border);

    const wallHeight = 0.8;
    const fenceGroup = new THREE.Group();

    const ringRadius = ARENA_RADIUS + 0.3;
    const ringTube = 0.12;
    const ringGeo = new THREE.TorusGeometry(ringRadius, ringTube, 16, 96);

    const ringMat = new THREE.MeshStandardMaterial({
      color: 0xff3333,
      emissive: 0xff2222,
      emissiveIntensity: 1.5,
      metalness: 0.6,
      roughness: 0.25,
    });

    const ringCount = 5;
    const totalHeight = wallHeight;
    const step = totalHeight / (ringCount - 1);

    for (let i = 0; i < ringCount; i++) {
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.2 + i * step;
      fenceGroup.add(ring);
    }

    scene.add(fenceGroup);

    const particleCount = 800;
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);

    const particlesGeo = new THREE.BufferGeometry();
    const minY = 0.1;
    const maxY = wallHeight + 0.7;

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const angle = Math.random() * Math.PI * 2;
      const radius = ARENA_RADIUS + 0.3 + Math.random() * 0.6;

      positions[i3 + 0] = Math.cos(angle) * radius;
      positions[i3 + 1] = minY + Math.random() * (maxY - minY);
      positions[i3 + 2] = Math.sin(angle) * radius;

      velocities[i3 + 0] = (Math.random() - 0.5) * 0.01;
      velocities[i3 + 1] = 0.01 + Math.random() * 0.02;
      velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
    }

    particlesGeo.setAttribute(
      "position",
      new THREE.BufferAttribute(positions, 3)
    );

    const particlesMat = new THREE.PointsMaterial({
      color: 0xff6666,
      size: 0.08,
      transparent: true,
      opacity: 0.9,
    });

    const wallParticles = new THREE.Points(particlesGeo, particlesMat);
    scene.add(wallParticles);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 15, 10);
    scene.add(dirLight);

    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);

    const playerMeshes = {};
    const playerStreaks = {};
    let myId = null;

    const BUMPER_RADIUS = 1.2;

    const myVelocity = { x: 0, z: 0 };
    const ACCEL = 0.0034;
    const FRICTION = 0.95;
    const BOUNCE_FACTOR = 4.2;
    const MIN_BOUNCE_SPEED = 0.08;
    const OVERLAP_BONUS = 0.05;

    const cameraOffset = new THREE.Vector3(0, 5, 10);
    const cameraTarget = new THREE.Vector3();

    let isDead = false;
    let respawnAt = 0;
    const RESPAWN_DELAY = 3000;
    let myStreak = 0;
    let lastStreakBeforeDeath = 0;

    const explosions = [];
    let lastTime = performance.now();

    function applyStreakScale(id) {
      const mesh = playerMeshes[id];
      if (!mesh) return;
      const streak = playerStreaks[id] || 0;
      const scale = 1 + 0.15 * Math.min(streak, 5);
      mesh.scale.set(scale, scale, scale);
    }

    function createPlayerMesh(id, color, x, y, z) {
      const group = new THREE.Group();

      const baseGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.4, 24);
      const baseMat = new THREE.MeshStandardMaterial({ color });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);

      const ringGeo = new THREE.TorusGeometry(1.2, 0.15, 16, 32);
      const ringMatCar = new THREE.MeshStandardMaterial({ color: 0x000000 });
      const ring = new THREE.Mesh(ringGeo, ringMatCar);
      ring.rotation.x = Math.PI / 2;
      group.add(ring);

      const seatGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 16);
      const seatMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const seat = new THREE.Mesh(seatGeo, seatMat);
      seat.position.y = 0.5;
      group.add(seat);

      group.position.set(x, y, z);
      scene.add(group);
      playerMeshes[id] = group;

      if (!(id in playerStreaks)) {
        playerStreaks[id] = 0;
      }
      applyStreakScale(id);
    }

    function removePlayerMesh(id) {
      const mesh = playerMeshes[id];
      if (!mesh) return;
      scene.remove(mesh);
      mesh.traverse((child) => {
        if (child.isMesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
      delete playerMeshes[id];
      delete playerStreaks[id];
    }

    // ---------- Explosion Particles ----------
    function spawnExplosion(pos) {
      console.log("Spawning explosion at", pos.x, pos.y, pos.z);
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;

        positions[i3 + 0] = pos.x;
        positions[i3 + 1] = pos.y + 0.5;
        positions[i3 + 2] = pos.z;

        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const speed = 0.06 + Math.random() * 0.05;

        velocities[i3 + 0] = Math.sin(phi) * Math.cos(theta) * speed;
        velocities[i3 + 1] = Math.cos(phi) * speed;
        velocities[i3 + 2] = Math.sin(phi) * Math.sin(theta) * speed;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const mat = new THREE.PointsMaterial({
        color: 0xffdd66,
        size: 0.18,
        transparent: true,
        opacity: 1,
      });

      const points = new THREE.Points(geo, mat);
      points.userData = {
        velocities,
        life: 0,
      };

      scene.add(points);
      explosions.push(points);
    }

    function updateExplosions(dt) {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const p = explosions[i];
        const positions = p.geometry.attributes.position.array;
        const velocities = p.userData.velocities;
        p.userData.life += dt;

        for (let j = 0; j < velocities.length / 3; j++) {
          const j3 = j * 3;
          positions[j3 + 0] += velocities[j3 + 0] * dt * 60;
          positions[j3 + 1] += velocities[j3 + 1] * dt * 60;
          positions[j3 + 2] += velocities[j3 + 2] * dt * 60;

          // gravity
          velocities[j3 + 1] -= 0.0015;
        }

        p.geometry.attributes.position.needsUpdate = true;

        const mat = p.material;
        mat.opacity = Math.max(0, 1 - p.userData.life / 0.8);

        if (p.userData.life > 0.8) {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
          explosions.splice(i, 1);
        }
      }
    }

    // ---------- Death & Respawn ----------
    function handleDeath() {
      if (!myId || isDead) return;
      const me = playerMeshes[myId];
      if (!me) return;

      const pos = me.position.clone();

      lastStreakBeforeDeath = myStreak;

      socket.emit("playerDied", {
        x: pos.x,
        y: pos.y,
        z: pos.z,
      });

      me.visible = false;
      myVelocity.x = 0;
      myVelocity.z = 0;

      isDead = true;
      respawnAt = performance.now() + RESPAWN_DELAY;
    }

    function respawnPlayer() {
      if (!myId) return;
      const me = playerMeshes[myId];
      if (!me) return;

      me.position.set(0, 0.5, 0);
      myVelocity.x = 0;
      myVelocity.z = 0;
      me.visible = true;

      isDead = false;

      socket.emit("playerRespawned", {
        x: me.position.x,
        y: me.position.y,
        z: me.position.z,
      });

      console.log("âœ¨ Respawned!");
    }

    function updateRespawnOverlay() {
      if (!isDead) {
        respawnOverlay.style.display = "none";
        return;
      }

      const remainingMs = respawnAt - performance.now();
      const remaining = Math.max(0, Math.ceil(remainingMs / 1000));

      respawnOverlay.style.display = "block";
      respawnOverlay.textContent = `Respawning in ${remaining}â€¦ (Streak: ${lastStreakBeforeDeath})`;
    }

    socket.on("connect", () => {
      myId = socket.id;
      console.log("Connected as", myId);
      playerStreaks[myId] = 0;
      myStreak = 0;
    });

    socket.on("currentPlayers", (players) => {
      for (const [id, p] of Object.entries(players)) {
        createPlayerMesh(id, p.color, p.x, p.y, p.z);
      }
    });

    socket.on("newPlayer", (p) => {
      createPlayerMesh(p.id, p.color, p.x, p.y, p.z);
    });

    socket.on("playerMoved", (p) => {
      const mesh = playerMeshes[p.id];
      if (!mesh) return;
      mesh.position.set(p.x, p.y, p.z);
    });

    socket.on("applyImpulse", ({ nx, nz, speed }) => {
      console.log("impulse:", nx, nz, speed);
      if (!myId) return;
      const me = playerMeshes[myId];
      if (!me) return;

      myVelocity.x += nx * speed;
      myVelocity.z += nz * speed;
    });

    socket.on("playerDisconnected", (id) => {
      removePlayerMesh(id);
    });

    socket.on("playerDied", ({ id, x, y, z }) => {
      const mesh = playerMeshes[id];
      if (mesh) {
        mesh.visible = false;
      }
      spawnExplosion(new THREE.Vector3(x, y, z));
    });

    socket.on("playerRespawned", (p) => {
      const mesh = playerMeshes[p.id];
      if (!mesh) return;
      mesh.visible = true;
      mesh.position.set(p.x, p.y, p.z);
    });

    socket.on("killCredit", ({ streak }) => {
      console.log("ðŸ”¥ Kill credited. New streak:", streak);
      myStreak = streak;
      playerStreaks[myId] = streak;
      applyStreakScale(myId);
    });

    socket.on("streakUpdate", ({ id, streak }) => {
      playerStreaks[id] = streak;
      applyStreakScale(id);
      if (id === myId) {
        myStreak = streak;
      }
    });

    const keys = { w: false, a: false, s: false, d: false };

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k in keys) keys[k] = true;
    });

    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k in keys) keys[k] = false;
    });

    function resolvePlayerCollisions() {
      if (!myId) return;
      const me = playerMeshes[myId];
      if (!me) return;

      for (const [id, other] of Object.entries(playerMeshes)) {
        if (id === myId) continue;

        const dx = me.position.x - other.position.x;
        const dz = me.position.z - other.position.z;
        const distSq = dx * dx + dz * dz;

        // effective radii grow with streak
        const myR = BUMPER_RADIUS * (1 + 0.15 * Math.min(playerStreaks[myId] || 0, 5));
        const otherR = BUMPER_RADIUS * (1 + 0.15 * Math.min(playerStreaks[id] || 0, 5));
        const minDist = myR + otherR;

        if (distSq <= minDist * minDist) {
          console.log("COLLISION detected with:", id);
        }
        if (distSq === 0 || distSq > minDist * minDist) continue;

        const dist = Math.sqrt(distSq);
        const overlap = minDist - dist;

        const nx = dx / dist;
        const nz = dz / dist;

        const push = overlap * 0.5;
        me.position.x += nx * push;
        me.position.z += nz * push;
        other.position.x -= nx * push;
        other.position.z -= nz * push;

        const vDotN = myVelocity.x * nx + myVelocity.z * nz;

        if (vDotN < 0) {
          const overlapStrength = overlap * OVERLAP_BONUS;

          let baseBounceSpeed = -vDotN * BOUNCE_FACTOR + overlapStrength;
          baseBounceSpeed = Math.max(baseBounceSpeed, MIN_BOUNCE_SPEED);

          const knockMult = 1 + 0.25 * (myStreak || 0);
          const targetBounceSpeed = baseBounceSpeed * knockMult;

          myVelocity.x = nx * baseBounceSpeed;
          myVelocity.z = nz * baseBounceSpeed;

          socket.emit("collisionImpulse", {
            targetId: id,
            nx,
            nz,
            speed: targetBounceSpeed,
          });
        }
      }
    }

    function updateLocalPlayer() {
      if (!myId) return;
      const me = playerMeshes[myId];
      if (!me) return;

      if (isDead) {
        if (performance.now() >= respawnAt) {
          respawnPlayer();
        }
        return;
      }

      if (keys.w) myVelocity.z -= ACCEL;
      if (keys.s) myVelocity.z += ACCEL;
      if (keys.a) myVelocity.x -= ACCEL;
      if (keys.d) myVelocity.x += ACCEL;

      myVelocity.x *= FRICTION;
      myVelocity.z *= FRICTION;

      me.position.x += myVelocity.x;
      me.position.z += myVelocity.z;

      const r = Math.sqrt(
        me.position.x * me.position.x + me.position.z * me.position.z
      );

      if (r > ARENA_RADIUS) {
        handleDeath();
        return;
      }

      resolvePlayerCollisions();

      socket.emit("move", {
        x: me.position.x,
        y: me.position.y,
        z: me.position.z,
      });

      const desired = me.position.clone().add(cameraOffset);
      camera.position.lerp(desired, 0.15);
      cameraTarget.copy(me.position);
      camera.lookAt(cameraTarget);
    }

    camera.position.set(0, 8, 15);
    camera.lookAt(0, 0, 0);

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      updateLocalPlayer();
      updateExplosions(dt);
      updateRespawnOverlay();

      const t = now * 0.002;
      ringMat.emissiveIntensity = 1.3 + Math.sin(t * 3) * 0.4;

      const pos = particlesGeo.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        pos[i3 + 0] += velocities[i3 + 0];
        pos[i3 + 1] += velocities[i3 + 1];
        pos[i3 + 2] += velocities[i3 + 2];

        if (pos[i3 + 1] > maxY) {
          const angle = Math.random() * Math.PI * 2;
          const radius = ARENA_RADIUS + 0.3 + Math.random() * 0.6;

          pos[i3 + 0] = Math.cos(angle) * radius;
          pos[i3 + 1] = minY;
          pos[i3 + 2] = Math.sin(angle) * radius;
        }
      }
      particlesGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>